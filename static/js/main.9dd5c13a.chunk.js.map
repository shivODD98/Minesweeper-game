{"version":3,"sources":["components/GameCell.js","components/GameHeader.js","components/GameContainer.js","App.js","serviceWorker.js","index.js"],"names":["GameCell","props","useState","startTapHold","setStartTapHold","disableClick","setDisableClick","uncoverCell","markCell","row","col","mine","count","status","useEffect","timerId","setTimeout","markCellCallBack","clearTimeout","handleCellClick","event","console","log","type","preventDefault","onClick","onContextMenu","onMouseDown","onMouseUp","onMouseLeave","onTouchStart","onTouchEnd","className","GameHeader","gameType","setGameType","handleDifficultyChange","target","value","onChange","GameContainer","gameBoard","setGameBoard","numberOfUncoveredCells","setNumberOfUncoveredCells","numberOfMarkedCells","setNumberOfMarkedCells","numberOfMines","setNumberOfMines","exploded","setExploded","win","setWin","easyGameBoard","cols","rows","mines","hardGameBoard","endGame","randomInt","min","max","Math","ceil","floor","random","validCoord","r","c","res","dr","dc","allowed","abs","push","length","i","j","sprinkleMines","ff","countGameBoardShownCells","newStatus","createGameCells","gameCells","winOrLose","restartGame","renderGameBoard","flagsLeft","startGame","playGame","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.9dd5c13a.chunk.js","sourcesContent":["import React,  {useEffect, useState, useCallback  }from 'react';\r\nimport '../styles/App.css';\r\n\r\nfunction GameCell(props) {\r\n  const [startTapHold, setStartTapHold] = useState(false);\r\n  const [disableClick, setDisableClick] = useState(false);\r\n  const ms = 300;\r\n  const {\r\n    uncoverCell,\r\n    markCell,\r\n    row,\r\n    col,\r\n    mine,\r\n    count,\r\n    status,\r\n  } = props;\r\n\r\n  useEffect(()=> {\r\n  }, [mine])\r\n\r\n  \r\n  useEffect(() => {\r\n    let timerId;\r\n    if (startTapHold) {\r\n      timerId = setTimeout(markCellCallBack, ms);\r\n    } else {\r\n      clearTimeout(timerId);\r\n    }\r\n    return () => {\r\n      clearTimeout(timerId);\r\n    };\r\n  }, [markCell, ms, startTapHold]);\r\n\r\n  const markCellCallBack = () => {\r\n    const newStatus = status === 'hidden' ? 'marked' : 'hidden';\r\n    markCell(row, col, newStatus)\r\n    setDisableClick(true);\r\n    setTimeout(() => {setDisableClick(false);}, 1000);\r\n  }\r\n\r\n  const handleCellClick = (event) => {\r\n    console.log(event.type)\r\n    switch(event.type) {\r\n      case 'mousedown': {\r\n        setStartTapHold(true);\r\n        break;\r\n      }\r\n      case 'mouseup': {\r\n        setStartTapHold(false);\r\n        break;\r\n      }\r\n      case 'mouseleave': {\r\n        setStartTapHold(false);\r\n        break;\r\n      }\r\n      case 'touchstart': {\r\n        setStartTapHold(true);\r\n        break;\r\n      }\r\n      case 'touchend': {\r\n        setStartTapHold(false);\r\n        break;\r\n      }\r\n      case 'click': {\r\n        if (!disableClick ){\r\n          uncoverCell(row, col)\r\n        }\r\n        break;\r\n      }\r\n      case 'contextmenu': {\r\n        event.preventDefault();\r\n        markCellCallBack();\r\n        break;\r\n      }\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  const renderGridCell = () => {\r\n      return (\r\n        <div \r\n          onClick={handleCellClick}\r\n          onContextMenu={handleCellClick}\r\n          onMouseDown={handleCellClick}\r\n          onMouseUp={handleCellClick}\r\n          onMouseLeave={handleCellClick}\r\n          onTouchStart={handleCellClick}\r\n          onTouchEnd={handleCellClick}\r\n          className={`grid-cell${'-' + status}`}>\r\n            <div>{mine === true ? 'mine' : ''}</div>\r\n            <div>{count}</div>\r\n        </div>\r\n      )\r\n  }\r\n\r\n  return (\r\n    renderGridCell()\r\n  );\r\n}\r\n\r\nexport default GameCell;\r\n","import React,  {useEffect, useState }from 'react';\r\nimport '../styles/App.css';\r\n\r\nfunction GameHeader(props) {\r\n  const [testVar, setTestVar] = useState(1);\r\n  const {\r\n    gameType,\r\n    setGameType,\r\n  } = props;\r\n\r\n  useEffect(()=> {\r\n  }, [])\r\n\r\n  const handleDifficultyChange = (event) => {\r\n    setGameType(event.target && event.target.value)\r\n  }\r\n\r\n  const renderDifficultyDropDown = () => {\r\n    return (\r\n      <div className=\"game-header-dificulty\">\r\n        <select className=\"game-header-difficulty-dropdown\" value={gameType} onChange={handleDifficultyChange}>\r\n          <option value=\"easy\">Easy</option>\r\n          <option value=\"hard\">Hard</option>\r\n        </select>\r\n      </div>\r\n    )\r\n  }\r\n\r\n  const renderNumberOfFlags = () => {\r\n    return (\r\n      <div className=\"game-header-flags\">POOOO</div>\r\n    )\r\n  }\r\n\r\n  const renderTime = () => {\r\n    return (\r\n      <div className=\"game-header-time\">000</div>\r\n    )\r\n  }\r\n\r\n  const renderGameHeader = () => {\r\n      return (\r\n        <div className=\"game-header\">\r\n          {renderDifficultyDropDown()}\r\n          {renderNumberOfFlags()}\r\n          {renderTime()}\r\n        </div>\r\n      )\r\n  }\r\n\r\n  return (\r\n    renderGameHeader()\r\n  );\r\n}\r\n\r\nexport default GameHeader;\r\n","import React,  {Fragment, useEffect, useState }from 'react';\r\nimport '../styles/App.css';\r\nimport GameCell from './GameCell';\r\nimport GameHeader from './GameHeader';\r\n\r\nfunction GameContainer(props) {\r\n  const [testVar, setTestVar] = useState(1);\r\n  const [gameType, setGameType] = useState('easy');\r\n  const [gameBoard, setGameBoard] = useState([]);\r\n  const [numberOfUncoveredCells, setNumberOfUncoveredCells] = useState(0);\r\n  const [numberOfMarkedCells, setNumberOfMarkedCells] = useState(0);\r\n  const [numberOfShownCells, setNumberOfShownCells] = useState(0);\r\n  const [numberOfMines, setNumberOfMines] = useState(10);\r\n  const [exploded, setExploded] = useState(false);\r\n  const [win, setWin] = useState(false);\r\n\r\n  const easyGameBoard = {\r\n    cols: 10,\r\n    rows: 8,\r\n    mines: 10,\r\n  };\r\n\r\n  const hardGameBoard = {\r\n    cols: 18,\r\n    rows: 14,\r\n    mines: 40,\r\n  };\r\n\r\n  useEffect(()=> {\r\n  },[gameType, setGameType])\r\n\r\n  useEffect(()=> {\r\n},[numberOfUncoveredCells, setNumberOfUncoveredCells])\r\n\r\n  useEffect(()=> {\r\n},[numberOfMarkedCells, setNumberOfMarkedCells])\r\n\r\n  useEffect(()=> {\r\n    if (exploded) {\r\n        endGame('lost')\r\n    }\r\n  },[exploded, setExploded])\r\n\r\n  useEffect(()=> {\r\n    if (win) {\r\n        endGame('won')\r\n    }\r\n  },[win, setWin])\r\n\r\n  useEffect(()=> {\r\n  },[gameBoard, setGameBoard])\r\n\r\n  const randomInt = (min, max) => {\r\n    [min,max] = [Math.ceil(min), Math.floor(max)]\r\n    return min + Math.floor(Math.random() * (max - min + 1));\r\n  }\r\n\r\n  const validCoord = (row, col) => {\r\n    const { rows, cols } = gameType === 'easy' ? easyGameBoard : hardGameBoard;\r\n    return row >= 0 && row < rows && col >= 0 && col < cols;\r\n}\r\n\r\n  const count = (row, col) => {\r\n    const c = (r,c) => {\r\n        return (validCoord(r, c) && (gameBoard[r][c].mine ? 1 : 0))};\r\n    let res = 0;\r\n    for( let dr = -1 ; dr <= 1 ; dr ++ )\r\n        for( let dc = -1 ; dc <= 1 ; dc ++ )\r\n            res += c(row+dr,col+dc);\r\n\r\n    return res;\r\n  }\r\n\r\n  const sprinkleMines = (row, col) => {\r\n    // prepare a list of allowed coordinates for mine placement\r\n    console.log('sprinkling mines')\r\n    const { rows, cols, mines } = gameType === 'easy' ? easyGameBoard : hardGameBoard;\r\n    let allowed = [];\r\n    for(let r = 0 ; r < rows ; r ++ ) {\r\n        for( let c = 0 ; c < cols ; c ++ ) {\r\n            if(Math.abs(row-r) > 2 || Math.abs(col-c) > 2) {\r\n            allowed.push([r,c]);\r\n            }\r\n        }\r\n    }\r\n    setNumberOfMines(Math.min(numberOfMines, allowed.length))\r\n    for( let i = 0 ; i < numberOfMines ; i ++ ) {\r\n        let j = randomInt(i, allowed.length-1);\r\n        [allowed[i], allowed[j]] = [allowed[j], allowed[i]];\r\n        let [r,c] = allowed[i];\r\n        gameBoard[r][c].mine=true;\r\n    }\r\n    // erase any marks (in case user placed them) and update counts\r\n    for(let r = 0 ; r < rows ; r ++ ) {\r\n        for( let c = 0 ; c < cols ; c ++ ) {\r\n            if(gameBoard[r][c].status === 'marked') {\r\n                gameBoard[r][c].status = 'hidden';\r\n            }\r\n            gameBoard[r][c].count = count(r,c);\r\n        }\r\n    }\r\n  }\r\n\r\n  const countGameBoardShownCells = () => {\r\n    const { rows, cols, mines } = gameType === 'easy' ? easyGameBoard : hardGameBoard;\r\n    let count = 0;\r\n    for(let i = 0; i < rows; i = i + 1) {\r\n      for(let j = 0; j < cols; j = j + 1) {\r\n        if (gameBoard[i][j].status === 'shown') {\r\n          count++;\r\n        }\r\n      }\r\n    }\r\n    return count;\r\n  }\r\n\r\n  const uncoverCell = (row, col) => {\r\n      if (numberOfUncoveredCells === 0) {\r\n          sprinkleMines(row, col);\r\n      }\r\n      if( gameBoard[row][col].status !== 'hidden') return false;\r\n      // floodfill all 0-count cells\r\n      let cellsUncovered = 0;\r\n      const ff = (r,c, count) => {\r\n        if( ! validCoord(r,c)) return;\r\n        if( gameBoard[r][c].status !== 'hidden') return;\r\n        gameBoard[r][c].status = 'shown';\r\n        setNumberOfUncoveredCells(numberOfUncoveredCells + 1);\r\n        if( gameBoard[r][c].count !== 0) return;\r\n        ff(r-1,c-1,count);ff(r-1,c,count);ff(r-1,c+1,count);\r\n        ff(r  ,c-1,count);         ;ff(r  ,c+1,count);\r\n        ff(r+1,c-1,count);ff(r+1,c, count);ff(r+1,c+1, count);\r\n      };\r\n      ff(row,col, cellsUncovered);\r\n      if( gameBoard[row][col].mine) {\r\n        setExploded(true);\r\n      }\r\n      const { rows, cols, mines } = gameType === 'easy' ? easyGameBoard : hardGameBoard;\r\n      const shownCells = countGameBoardShownCells()\r\n      if((shownCells + numberOfMines) === (rows*cols)){\r\n        setWin(true)\r\n      }\r\n      return true;\r\n  }\r\n\r\n  const markCell = (row, col, newStatus) => {\r\n    if( ! validCoord(row,col)) return false;\r\n    if( gameBoard[row][col].status === 'shown') return false;\r\n    setNumberOfMarkedCells( numberOfMarkedCells + (gameBoard[row][col].status == 'markded' ? -1 : 1));\r\n    gameBoard[row][col].status = newStatus;//'marked' //gameBoard[row][col].status == 'marked' \r\n    // ? 'hidden' : 'marked';\r\n    return true;\r\n  }\r\n\r\n  const createGameCells = (rows, cols) => {\r\n    const gameCells = [];\r\n    for(let i = 0; i < rows; i = i + 1) {\r\n        gameCells.push([])\r\n        for(let j = 0; j < cols; j = j + 1) {\r\n            gameCells[i].push(\r\n                <GameCell\r\n                    uncoverCell={uncoverCell}\r\n                    markCell={markCell}\r\n                    row={i}\r\n                    col={j}\r\n                    mine={gameBoard[i][j].mine}\r\n                    status={gameBoard[i][j].status}\r\n                    count={gameBoard[i][j].count}\r\n                />\r\n            )\r\n        }\r\n    }\r\n    return gameCells;\r\n  }\r\n\r\n  const endGame = (winOrLose) => {\r\n    setGameBoard(winOrLose === 'lost' ? \r\n    (<div onClick={() => restartGame()}>You Lost!!! ;</div>) : (<div onClick={() => restartGame()}>You WON!!! AHHH XD</div>))\r\n  }\r\n\r\n  const renderGameBoard = () => {\r\n    const { rows, cols, mines } = gameType === 'easy' ? easyGameBoard : hardGameBoard;\r\n    for(let i = 0; i < rows; i = i + 1) {\r\n        gameBoard.push([])\r\n        for(let j = 0; j < cols; j = j + 1) {\r\n            gameBoard[i].push(\r\n                {\r\n                    row: i,\r\n                    col: j,\r\n                    mine: false,\r\n                    status: 'hidden',\r\n                    count: 0,\r\n                }\r\n            )\r\n        }\r\n    }\r\n    return (\r\n        <div className={gameType + '-grid-container'}>\r\n            {createGameCells(rows, cols)}\r\n        </div>\r\n      )\r\n  }\r\n\r\n  const restartGame = () => {\r\n      setExploded(false);\r\n      setWin(false);\r\n      setNumberOfUncoveredCells(0);\r\n      setNumberOfMines(10);\r\n      setGameBoard([]);\r\n      renderGameBoard();\r\n  }\r\n\r\n  const playGame = () => {\r\n      if ((exploded || win) && gameBoard && gameBoard.type === 'div') {\r\n        return gameBoard;\r\n      }\r\n      if(gameBoard.length === 0) {\r\n          return renderGameBoard()\r\n      }\r\n      const { rows, cols, mines } = gameType === 'easy' ? easyGameBoard : hardGameBoard;\r\n      return (\r\n        <div className={gameType + '-grid-container'}>\r\n            {createGameCells(rows, cols)}\r\n        </div>\r\n      )\r\n  }\r\n\r\n  return (\r\n    <Fragment>\r\n        <GameHeader\r\n            gameType={gameType}\r\n            setGameType={setGameType}\r\n            flagsLeft={0}\r\n            startGame={false}\r\n        />  \r\n        {playGame()}\r\n    </Fragment>\r\n  );\r\n}\r\n\r\nexport default GameContainer;\r\n","import React,  {useEffect, useState }from 'react';\nimport './styles/App.css';\nimport GameContainer from './components/GameContainer';\n\nfunction App() {\n  useEffect(()=> {\n  },)\n\n  return (\n    <div className=\"App\">\n      <div className=\"Game-Container\">\n        <GameContainer/>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}